---
source: crates/analyzer/tests/analysis.rs
expression: "build_snapshot(&db, module)"
---
note: 
  ┌─ enum_match.fe:2:5
  │
2 │     Unit
  │     ^^^^ unit
3 │     UnitTuple()
  │     ^^^^^^^^^^^ ()
4 │     Tuple(u32, u256)
  │     ^^^^^^^^^^^^^^^^ (u32, u256)

note: 
  ┌─ enum_match.fe:8:5
  │
8 │     Tuple(u32, u256)
  │     ^^^^^^^^^^^^^^^^ (u32, u256)
9 │     Nested(MyEnum)
  │     ^^^^^^^^^^^^^^ (MyEnum)

note: 
   ┌─ enum_match.fe:13:5
   │
13 │     Value(MyEnum, MyEnum)
   │     ^^^^^^^^^^^^^^^^^^^^^ (MyEnum, MyEnum)

note: 
   ┌─ enum_match.fe:17:5
   │
17 │     Continue
   │     ^^^^^^^^ unit
18 │     Done
   │     ^^^^ unit

note: 
   ┌─ enum_match.fe:22:5
   │
22 │     my_enum: MyEnumNested
   │     ^^^^^^^^^^^^^^^^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:24:5
   │  
24 │ ╭     pub fn simple_match(x: u32, y: u256) -> u256 {
25 │ │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
26 │ │         match my_enum {
27 │ │             MyEnum::Unit | MyEnum::UnitTuple() => {
   · │
33 │ │         }
34 │ │     }
   │ ╰─────^ self: None, params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }] -> u256

note: 
   ┌─ enum_match.fe:25:13
   │
25 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │             ^^^^^^^ MyEnum

note: 
   ┌─ enum_match.fe:25:45
   │
25 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │                                             ^  ^ u256: Value
   │                                             │   
   │                                             u32: Value

note: 
   ┌─ enum_match.fe:25:31
   │
25 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │                               ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
26 │         match my_enum {
   │               ^^^^^^^ MyEnum: Memory
27 │             MyEnum::Unit | MyEnum::UnitTuple() => {
28 │                 return 0
   │                        ^ u256: Value
   ·
31 │                 return u256(x1) + y1
   │                             ^^ u32: Value

note: 
   ┌─ enum_match.fe:31:24
   │
31 │                 return u256(x1) + y1
   │                        ^^^^^^^^   ^^ u256: Value
   │                        │           
   │                        u256: Value

note: 
   ┌─ enum_match.fe:31:24
   │
31 │                 return u256(x1) + y1
   │                        ^^^^^^^^^^^^^ u256: Value

note: 
   ┌─ enum_match.fe:36:5
   │  
36 │ ╭     pub fn nested_match(x: u32, y: u256) -> u256 {
37 │ │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
38 │ │         match nested {
39 │ │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
   · │
45 │ │         }
46 │ │     }
   │ ╰─────^ self: None, params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }] -> u256

note: 
   ┌─ enum_match.fe:37:13
   │
37 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │             ^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:37:71
   │
37 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                                                       ^  ^ u256: Value
   │                                                                       │   
   │                                                                       u32: Value

note: 
   ┌─ enum_match.fe:37:57
   │
37 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                                         ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory

note: 
   ┌─ enum_match.fe:37:36
   │
37 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
38 │         match nested {
   │               ^^^^^^ MyEnumNested: Memory
39 │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
40 │                 return u256(x1) + y1
   │                             ^^ u32: Value

note: 
   ┌─ enum_match.fe:40:24
   │
40 │                 return u256(x1) + y1
   │                        ^^^^^^^^   ^^ u256: Value
   │                        │           
   │                        u256: Value

note: 
   ┌─ enum_match.fe:40:24
   │
40 │                 return u256(x1) + y1
   │                        ^^^^^^^^^^^^^ u256: Value
   ·
43 │                 return 0
   │                        ^ u256: Value

note: 
   ┌─ enum_match.fe:48:5
   │  
48 │ ╭     pub fn nested_match2() -> u256 {
49 │ │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
50 │ │         let res: u256 = 0
51 │ │         match tup {
   · │
60 │ │         return res
61 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:49:13
   │
49 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │             ^^^ Tuple2
50 │         let res: u256 = 0
   │             ^^^ u256

note: 
   ┌─ enum_match.fe:49:55
   │
49 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                                       ^  ^ u256: Value
   │                                                       │   
   │                                                       u32: Value

note: 
   ┌─ enum_match.fe:49:41
   │
49 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
   │                                         │                     
   │                                         MyEnum: Memory

note: 
   ┌─ enum_match.fe:49:27
   │
49 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Tuple2: Memory
50 │         let res: u256 = 0
   │                         ^ u256: Value
51 │         match tup {
   │               ^^^ Tuple2: Memory
52 │             Tuple2::Value(MyEnum::Unit, MyEnum::Tuple(x, y)) | Tuple2::Value(MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
53 │                 res = u256(x) + y
   │                 ^^^        ^ u32: Value
   │                 │           
   │                 u256: Value

note: 
   ┌─ enum_match.fe:53:23
   │
53 │                 res = u256(x) + y
   │                       ^^^^^^^   ^ u256: Value
   │                       │          
   │                       u256: Value

note: 
   ┌─ enum_match.fe:53:23
   │
53 │                 res = u256(x) + y
   │                       ^^^^^^^^^^^ u256: Value
   ·
56 │                 return 0
   │                        ^ u256: Value
   ·
60 │         return res
   │                ^^^ u256: Value

note: 
   ┌─ enum_match.fe:63:5
   │  
63 │ ╭     pub fn tuple_match() -> u256 {
64 │ │         let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
65 │ │         match tup {
66 │ │             (MyEnum::Unit, MyEnum::Tuple(x, y)) | (MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
   · │
73 │ │         }
74 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:64:13
   │
64 │         let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │             ^^^ (MyEnum, MyEnum)

note: 
   ┌─ enum_match.fe:64:52
   │
64 │         let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                                    ^  ^ u256: Value
   │                                                    │   
   │                                                    u32: Value

note: 
   ┌─ enum_match.fe:64:38
   │
64 │         let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                      ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
   │                                      │                     
   │                                      MyEnum: Memory

note: 
   ┌─ enum_match.fe:64:37
   │
64 │         let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (MyEnum, MyEnum): Memory
65 │         match tup {
   │               ^^^ (MyEnum, MyEnum): Memory
66 │             (MyEnum::Unit, MyEnum::Tuple(x, y)) | (MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
67 │                 return u256(x) + y
   │                             ^ u32: Value

note: 
   ┌─ enum_match.fe:67:24
   │
67 │                 return u256(x) + y
   │                        ^^^^^^^   ^ u256: Value
   │                        │          
   │                        u256: Value

note: 
   ┌─ enum_match.fe:67:24
   │
67 │                 return u256(x) + y
   │                        ^^^^^^^^^^^ u256: Value
   ·
71 │                 return 0
   │                        ^ u256: Value

note: 
   ┌─ enum_match.fe:76:5
   │  
76 │ ╭     pub fn wild_card() -> u256 {
77 │ │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
78 │ │         match nested {
79 │ │             MyEnumNested::Nested(MyEnum::UnitTuple() | MyEnum::Tuple(_, _)) => {
   · │
85 │ │         }
86 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:77:13
   │
77 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │             ^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:77:57
   │
77 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │                                                         ^^^^^^^^^^^^ MyEnum: Memory

note: 
   ┌─ enum_match.fe:77:36
   │
77 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
78 │         match nested {
   │               ^^^^^^ MyEnumNested: Memory
79 │             MyEnumNested::Nested(MyEnum::UnitTuple() | MyEnum::Tuple(_, _)) => {
80 │                 return 100
   │                        ^^^ u256: Value
   ·
83 │                 return 0
   │                        ^ u256: Value

note: 
    ┌─ enum_match.fe:88:5
    │  
 88 │ ╭     pub fn match_in_if() -> u256 {
 89 │ │         let res: u256 = 0
 90 │ │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
 91 │ │ 
    · │
107 │ │ 
108 │ │     }
    │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:89:13
   │
89 │         let res: u256 = 0
   │             ^^^ u256
90 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │             ^^^^^^^ MyEnum

note: 
   ┌─ enum_match.fe:89:25
   │
89 │         let res: u256 = 0
   │                         ^ u256: Value
90 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │                                             ^  ^ u256: Value
   │                                             │   
   │                                             u32: Value

note: 
   ┌─ enum_match.fe:90:31
   │
90 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │                               ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
91 │ 
92 │         if true {
   │            ^^^^ bool: Value
93 │             match my_enum {
   │                   ^^^^^^^ MyEnum: Memory
94 │                 MyEnum::Tuple(x, y) => {
95 │                     res = u256(x) + y
   │                     ^^^        ^ u32: Value
   │                     │           
   │                     u256: Value

note: 
   ┌─ enum_match.fe:95:27
   │
95 │                     res = u256(x) + y
   │                           ^^^^^^^   ^ u256: Value
   │                           │          
   │                           u256: Value

note: 
    ┌─ enum_match.fe:95:27
    │
 95 │                     res = u256(x) + y
    │                           ^^^^^^^^^^^ u256: Value
    ·
 99 │                     res = 0
    │                     ^^^   ^ u256: Value
    │                     │      
    │                     u256: Value
    ·
103 │             res = 100
    │             ^^^   ^^^ u256: Value
    │             │      
    │             u256: Value
    ·
106 │         return res
    │                ^^^ u256: Value

note: 
    ┌─ enum_match.fe:110:5
    │  
110 │ ╭     pub fn match_in_loop() -> u256 {
111 │ │         let res: u256 = 0
112 │ │         let state: State = State::Continue 
113 │ │ 
    · │
133 │ │         return res
134 │ │     }
    │ ╰─────^ self: None, params: [] -> u256

note: 
    ┌─ enum_match.fe:111:13
    │
111 │         let res: u256 = 0
    │             ^^^ u256
112 │         let state: State = State::Continue 
    │             ^^^^^ State
113 │ 
114 │         let my_array: Array<u256, 3> = [0; 3]
    │             ^^^^^^^^ Array<u256, 3>
    ·
119 │         for i in my_array {
    │             ^ u256

note: 
    ┌─ enum_match.fe:111:25
    │
111 │         let res: u256 = 0
    │                         ^ u256: Value
112 │         let state: State = State::Continue 
    │                            ^^^^^^^^^^^^^^^ State: Memory
113 │ 
114 │         let my_array: Array<u256, 3> = [0; 3]
    │                                         ^  ^ u256: Value
    │                                         │   
    │                                         u256: Value

note: 
    ┌─ enum_match.fe:114:40
    │
114 │         let my_array: Array<u256, 3> = [0; 3]
    │                                        ^^^^^^ Array<u256, 3>: Memory
115 │         my_array[0] = 5
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:115:9
    │
115 │         my_array[0] = 5
    │         ^^^^^^^^^^^   ^ u256: Value
    │         │              
    │         u256: Memory
116 │         my_array[1] = 10
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:116:9
    │
116 │         my_array[1] = 10
    │         ^^^^^^^^^^^   ^^ u256: Value
    │         │              
    │         u256: Memory
117 │         my_array[2] = 15
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:117:9
    │
117 │         my_array[2] = 15
    │         ^^^^^^^^^^^   ^^ u256: Value
    │         │              
    │         u256: Memory
118 │ 
119 │         for i in my_array {
    │                  ^^^^^^^^ Array<u256, 3>: Memory
120 │             match state {
    │                   ^^^^^ State: Memory
    ·
127 │             res += i
    │             ^^^    ^ u256: Value
    │             │       
    │             u256: Value
128 │             if res == 15 {
    │                ^^^    ^^ u256: Value
    │                │       
    │                u256: Value

note: 
    ┌─ enum_match.fe:128:16
    │
128 │             if res == 15 {
    │                ^^^^^^^^^ bool: Value
129 │                 state = State::Done
    │                 ^^^^^   ^^^^^^^^^^^ State: Memory
    │                 │        
    │                 State: Memory
    ·
133 │         return res
    │                ^^^ u256: Value

note: 
    ┌─ enum_match.fe:136:5
    │  
136 │ ╭     pub fn enum_storage(self, x:u32, y: u256, b: bool) -> u256 {
137 │ │         if b {
138 │ │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
139 │ │         } else {
    · │
150 │ │         }
151 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }, { label: None, name: b, typ: bool }] -> u256

note: 
    ┌─ enum_match.fe:137:12
    │
137 │         if b {
    │            ^ bool: Value
138 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │             ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:138:13
    │
138 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │             ^^^^^^^^^^^^                                      ^  ^ u256: Value
    │             │                                                 │   
    │             │                                                 u32: Value
    │             MyEnumNested: Storage { nonce: Some(0) }

note: 
    ┌─ enum_match.fe:138:49
    │
138 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │                                                 ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory

note: 
    ┌─ enum_match.fe:138:28
    │
138 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
139 │         } else {
140 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │             ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:140:13
    │
140 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │             ^^^^^^^^^^^^                        ^^^^^^^^^^^^ MyEnum: Memory
    │             │                                    
    │             MyEnumNested: Storage { nonce: Some(0) }

note: 
    ┌─ enum_match.fe:140:28
    │
140 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
    ·
143 │         match self.my_enum {
    │               ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:143:15
    │
143 │         match self.my_enum {
    │               ^^^^^^^^^^^^ MyEnumNested: Storage { nonce: Some(0) }
144 │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
145 │                 return u256(x1) + y1
    │                             ^^ u32: Value

note: 
    ┌─ enum_match.fe:145:24
    │
145 │                 return u256(x1) + y1
    │                        ^^^^^^^^   ^^ u256: Value
    │                        │           
    │                        u256: Value

note: 
    ┌─ enum_match.fe:145:24
    │
145 │                 return u256(x1) + y1
    │                        ^^^^^^^^^^^^^ u256: Value
    ·
148 │                 return 100
    │                        ^^^ u256: Value


