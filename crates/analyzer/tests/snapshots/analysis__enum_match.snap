---
source: crates/analyzer/tests/analysis.rs
expression: "build_snapshot(&db, module)"
---
note: 
  ┌─ enum_match.fe:2:5
  │
2 │     Unit
  │     ^^^^ unit
3 │     UnitTuple()
  │     ^^^^^^^^^^^ ()
4 │     Tuple(u32, u256)
  │     ^^^^^^^^^^^^^^^^ (u32, u256)

note: 
  ┌─ enum_match.fe:8:5
  │
8 │     Tuple(u32, u256)
  │     ^^^^^^^^^^^^^^^^ (u32, u256)
9 │     Nested(MyEnum)
  │     ^^^^^^^^^^^^^^ (MyEnum)

note: 
   ┌─ enum_match.fe:13:5
   │
13 │     Value(MyEnum, MyEnum)
   │     ^^^^^^^^^^^^^^^^^^^^^ (MyEnum, MyEnum)

note: 
   ┌─ enum_match.fe:18:5
   │
18 │     Continue
   │     ^^^^^^^^ unit
19 │     Done
   │     ^^^^ unit

note: 
   ┌─ enum_match.fe:23:5
   │
23 │     my_enum: MyEnumNested
   │     ^^^^^^^^^^^^^^^^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:25:5
   │  
25 │ ╭     pub fn simple_match(x: u32, y: u256) -> u256 {
26 │ │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
27 │ │         match my_enum {
28 │ │             MyEnum::Unit | MyEnum::UnitTuple() => {
   · │
34 │ │         }
35 │ │     }
   │ ╰─────^ self: None, params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }] -> u256

note: 
   ┌─ enum_match.fe:26:13
   │
26 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │             ^^^^^^^ MyEnum

note: 
   ┌─ enum_match.fe:26:45
   │
26 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │                                             ^  ^ u256: Value
   │                                             │   
   │                                             u32: Value

note: 
   ┌─ enum_match.fe:26:31
   │
26 │         let my_enum: MyEnum = MyEnum::Tuple(x, y);
   │                               ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
27 │         match my_enum {
   │               ^^^^^^^ MyEnum: Memory
28 │             MyEnum::Unit | MyEnum::UnitTuple() => {
29 │                 return 0
   │                        ^ u256: Value
   ·
32 │                 return u256(x1) + y1
   │                             ^^ u32: Value

note: 
   ┌─ enum_match.fe:32:24
   │
32 │                 return u256(x1) + y1
   │                        ^^^^^^^^   ^^ u256: Value
   │                        │           
   │                        u256: Value

note: 
   ┌─ enum_match.fe:32:24
   │
32 │                 return u256(x1) + y1
   │                        ^^^^^^^^^^^^^ u256: Value

note: 
   ┌─ enum_match.fe:37:5
   │  
37 │ ╭     pub fn nested_match(x: u32, y: u256) -> u256 {
38 │ │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
39 │ │         match nested {
40 │ │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
   · │
46 │ │         }
47 │ │     }
   │ ╰─────^ self: None, params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }] -> u256

note: 
   ┌─ enum_match.fe:38:13
   │
38 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │             ^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:38:71
   │
38 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                                                       ^  ^ u256: Value
   │                                                                       │   
   │                                                                       u32: Value

note: 
   ┌─ enum_match.fe:38:57
   │
38 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                                         ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory

note: 
   ┌─ enum_match.fe:38:36
   │
38 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
   │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
39 │         match nested {
   │               ^^^^^^ MyEnumNested: Memory
40 │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
41 │                 return u256(x1) + y1
   │                             ^^ u32: Value

note: 
   ┌─ enum_match.fe:41:24
   │
41 │                 return u256(x1) + y1
   │                        ^^^^^^^^   ^^ u256: Value
   │                        │           
   │                        u256: Value

note: 
   ┌─ enum_match.fe:41:24
   │
41 │                 return u256(x1) + y1
   │                        ^^^^^^^^^^^^^ u256: Value
   ·
44 │                 return 0
   │                        ^ u256: Value

note: 
   ┌─ enum_match.fe:49:5
   │  
49 │ ╭     pub fn nested_match2() -> u256 {
50 │ │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
51 │ │         let res: u256 = 0
52 │ │         match tup {
   · │
61 │ │         return res
62 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:50:13
   │
50 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │             ^^^ Tuple2
51 │         let res: u256 = 0
   │             ^^^ u256

note: 
   ┌─ enum_match.fe:50:55
   │
50 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                                       ^  ^ u256: Value
   │                                                       │   
   │                                                       u32: Value

note: 
   ┌─ enum_match.fe:50:41
   │
50 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                                         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
   │                                         │                     
   │                                         MyEnum: Memory

note: 
   ┌─ enum_match.fe:50:27
   │
50 │         let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
   │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Tuple2: Memory
51 │         let res: u256 = 0
   │                         ^ u256: Value
52 │         match tup {
   │               ^^^ Tuple2: Memory
53 │             Tuple2::Value(MyEnum::Unit, MyEnum::Tuple(x, y)) | Tuple2::Value(MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
54 │                 res = u256(x) + y
   │                 ^^^        ^ u32: Value
   │                 │           
   │                 u256: Value

note: 
   ┌─ enum_match.fe:54:23
   │
54 │                 res = u256(x) + y
   │                       ^^^^^^^   ^ u256: Value
   │                       │          
   │                       u256: Value

note: 
   ┌─ enum_match.fe:54:23
   │
54 │                 res = u256(x) + y
   │                       ^^^^^^^^^^^ u256: Value
   ·
57 │                 return 0
   │                        ^ u256: Value
   ·
61 │         return res
   │                ^^^ u256: Value

note: 
   ┌─ enum_match.fe:64:5
   │  
64 │ ╭     pub fn wild_card() -> u256 {
65 │ │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
66 │ │         match nested {
67 │ │             MyEnumNested::Nested(MyEnum::UnitTuple() | MyEnum::Tuple(_, _)) => {
   · │
73 │ │         }
74 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:65:13
   │
65 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │             ^^^^^^ MyEnumNested

note: 
   ┌─ enum_match.fe:65:57
   │
65 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │                                                         ^^^^^^^^^^^^ MyEnum: Memory

note: 
   ┌─ enum_match.fe:65:36
   │
65 │         let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
   │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
66 │         match nested {
   │               ^^^^^^ MyEnumNested: Memory
67 │             MyEnumNested::Nested(MyEnum::UnitTuple() | MyEnum::Tuple(_, _)) => {
68 │                 return 100
   │                        ^^^ u256: Value
   ·
71 │                 return 0
   │                        ^ u256: Value

note: 
   ┌─ enum_match.fe:76:5
   │  
76 │ ╭     pub fn match_in_if() -> u256 {
77 │ │         let res: u256 = 0
78 │ │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
79 │ │ 
   · │
95 │ │ 
96 │ │     }
   │ ╰─────^ self: None, params: [] -> u256

note: 
   ┌─ enum_match.fe:77:13
   │
77 │         let res: u256 = 0
   │             ^^^ u256
78 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │             ^^^^^^^ MyEnum

note: 
   ┌─ enum_match.fe:77:25
   │
77 │         let res: u256 = 0
   │                         ^ u256: Value
78 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │                                             ^  ^ u256: Value
   │                                             │   
   │                                             u32: Value

note: 
   ┌─ enum_match.fe:78:31
   │
78 │         let my_enum: MyEnum = MyEnum::Tuple(1, 2);
   │                               ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory
79 │ 
80 │         if true {
   │            ^^^^ bool: Value
81 │             match my_enum {
   │                   ^^^^^^^ MyEnum: Memory
82 │                 MyEnum::Tuple(x, y) => {
83 │                     res = u256(x) + y
   │                     ^^^        ^ u32: Value
   │                     │           
   │                     u256: Value

note: 
   ┌─ enum_match.fe:83:27
   │
83 │                     res = u256(x) + y
   │                           ^^^^^^^   ^ u256: Value
   │                           │          
   │                           u256: Value

note: 
   ┌─ enum_match.fe:83:27
   │
83 │                     res = u256(x) + y
   │                           ^^^^^^^^^^^ u256: Value
   ·
87 │                     res = 0
   │                     ^^^   ^ u256: Value
   │                     │      
   │                     u256: Value
   ·
91 │             res = 100
   │             ^^^   ^^^ u256: Value
   │             │      
   │             u256: Value
   ·
94 │         return res
   │                ^^^ u256: Value

note: 
    ┌─ enum_match.fe:98:5
    │  
 98 │ ╭     pub fn match_in_loop() -> u256 {
 99 │ │         let res: u256 = 0
100 │ │         let state: State = State::Continue 
101 │ │ 
    · │
121 │ │         return res
122 │ │     }
    │ ╰─────^ self: None, params: [] -> u256

note: 
    ┌─ enum_match.fe:99:13
    │
 99 │         let res: u256 = 0
    │             ^^^ u256
100 │         let state: State = State::Continue 
    │             ^^^^^ State
101 │ 
102 │         let my_array: Array<u256, 3> = [0; 3]
    │             ^^^^^^^^ Array<u256, 3>
    ·
107 │         for i in my_array {
    │             ^ u256

note: 
    ┌─ enum_match.fe:99:25
    │
 99 │         let res: u256 = 0
    │                         ^ u256: Value
100 │         let state: State = State::Continue 
    │                            ^^^^^^^^^^^^^^^ State: Memory
101 │ 
102 │         let my_array: Array<u256, 3> = [0; 3]
    │                                         ^  ^ u256: Value
    │                                         │   
    │                                         u256: Value

note: 
    ┌─ enum_match.fe:102:40
    │
102 │         let my_array: Array<u256, 3> = [0; 3]
    │                                        ^^^^^^ Array<u256, 3>: Memory
103 │         my_array[0] = 5
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:103:9
    │
103 │         my_array[0] = 5
    │         ^^^^^^^^^^^   ^ u256: Value
    │         │              
    │         u256: Memory
104 │         my_array[1] = 10
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:104:9
    │
104 │         my_array[1] = 10
    │         ^^^^^^^^^^^   ^^ u256: Value
    │         │              
    │         u256: Memory
105 │         my_array[2] = 15
    │         ^^^^^^^^ ^ u256: Value
    │         │         
    │         Array<u256, 3>: Memory

note: 
    ┌─ enum_match.fe:105:9
    │
105 │         my_array[2] = 15
    │         ^^^^^^^^^^^   ^^ u256: Value
    │         │              
    │         u256: Memory
106 │ 
107 │         for i in my_array {
    │                  ^^^^^^^^ Array<u256, 3>: Memory
108 │             match state {
    │                   ^^^^^ State: Memory
    ·
115 │             res += i
    │             ^^^    ^ u256: Value
    │             │       
    │             u256: Value
116 │             if res == 15 {
    │                ^^^    ^^ u256: Value
    │                │       
    │                u256: Value

note: 
    ┌─ enum_match.fe:116:16
    │
116 │             if res == 15 {
    │                ^^^^^^^^^ bool: Value
117 │                 state = State::Done
    │                 ^^^^^   ^^^^^^^^^^^ State: Memory
    │                 │        
    │                 State: Memory
    ·
121 │         return res
    │                ^^^ u256: Value

note: 
    ┌─ enum_match.fe:124:5
    │  
124 │ ╭     pub fn enum_storage(self, x:u32, y: u256, b: bool) -> u256 {
125 │ │         if b {
126 │ │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
127 │ │         } else {
    · │
138 │ │         }
139 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: x, typ: u32 }, { label: None, name: y, typ: u256 }, { label: None, name: b, typ: bool }] -> u256

note: 
    ┌─ enum_match.fe:125:12
    │
125 │         if b {
    │            ^ bool: Value
126 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │             ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:126:13
    │
126 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │             ^^^^^^^^^^^^                                      ^  ^ u256: Value
    │             │                                                 │   
    │             │                                                 u32: Value
    │             MyEnumNested: Storage { nonce: Some(0) }

note: 
    ┌─ enum_match.fe:126:49
    │
126 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │                                                 ^^^^^^^^^^^^^^^^^^^ MyEnum: Memory

note: 
    ┌─ enum_match.fe:126:28
    │
126 │             self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
127 │         } else {
128 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │             ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:128:13
    │
128 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │             ^^^^^^^^^^^^                        ^^^^^^^^^^^^ MyEnum: Memory
    │             │                                    
    │             MyEnumNested: Storage { nonce: Some(0) }

note: 
    ┌─ enum_match.fe:128:28
    │
128 │             self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ MyEnumNested: Memory
    ·
131 │         match self.my_enum {
    │               ^^^^ Foo: Value

note: 
    ┌─ enum_match.fe:131:15
    │
131 │         match self.my_enum {
    │               ^^^^^^^^^^^^ MyEnumNested: Storage { nonce: Some(0) }
132 │             MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
133 │                 return u256(x1) + y1
    │                             ^^ u32: Value

note: 
    ┌─ enum_match.fe:133:24
    │
133 │                 return u256(x1) + y1
    │                        ^^^^^^^^   ^^ u256: Value
    │                        │           
    │                        u256: Value

note: 
    ┌─ enum_match.fe:133:24
    │
133 │                 return u256(x1) + y1
    │                        ^^^^^^^^^^^^^ u256: Value
    ·
136 │                 return 100
    │                        ^^^ u256: Value


